### 二叉树中和为 k 的路径 （字节跳动面试原题）

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

示例:
给定如下二叉树，以及目标和  target = 22，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

返回:

[
[5,4,11,2],
[5,8,4,5]
]

## solution: 前序遍历+回溯法
- 考虑到计算路径，首先想到前序遍历，根-左-右。因此能考虑到在递归中，先对数据进行处理，然后递归左，右。
- 判断条件为：sum是否等于target + 是否到达叶子节点
- 一个小难点在于递归的时候，我们不能直接把tempRes直接赋值，需要进行一个浅拷贝。关于深拷贝/浅拷贝，一些拓展在下面。
- 时间复杂度: O(n) = n -> 遍历所有节点
- 空间复杂度：O(n) = H = n -> 树的高度. 树退化成链表. tempRes存了所有树的节点。

## 浅拷贝和深拷贝

- 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。
```
var a1 = {b: {c: {}};

var a2 = shallowClone(a1); // 浅拷贝方法
a2.b.c === a1.b.c // true 新旧对象还是共享同一块内存

var a3 = deepClone(a3); // 深拷贝方法
a3.b.c === a1.b.c // false 新对象跟原对象不共享内存

            和原数据是否指向同一个对象      第一层数据为基本数据类型       原数据中包含子对象
赋值        是                              改变会使原数据一起改变       改变会使原数据一起改变
浅拷贝      否                              改变不会使原数据一起改变     改变会使原数据一起改变
深拷贝      否                              改变不会使原数据一起改变     改变不会使原数据一起改变
```

- 浅拷贝的实现方式 （NodeJS）
    1. Object.assign()
    2. lodash -> clone method
    3. 展开运算符... -> let obj2= {... obj1}
    4. Array.prototype.concat()
    5. Array.prototype.slice()

- 深拷贝：（NodeJS）
    1. JSON.parse(JSON.stringify())
    2. lodash -> _.cloneDeep()
    3. jQuery.extend()