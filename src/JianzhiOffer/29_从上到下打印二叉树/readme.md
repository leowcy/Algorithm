### 打印二叉树

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

例如:
给定二叉树: [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```

返回：
[3,9,20,15,7]

## solution: BFS - Breadth first search

- BFS 广度优先算法，解决层次遍历。因为需要按层打印，并且先打印更节点，然后打印他们的子节点，如果存在的话。
  因此想到需要使用一个队列 queue 来实现，满足先进先出。我们先把根节点放入队列，然后再放他们的左右子节点。
  在 Js 中，都是使用数组来实现。push 放入队尾，shift 从对头提出，来实现 queue 的功能。
- 如果左右孩子不存在，则直接打印该节点。
- 还有一个初始化的问题，是一个小难点。我们初始化队列的时候，直接把 root 放入其中，作为起始。然后这题不需要进行
  递归调用，只需要一个 while 循环，然后我们一直重复的去增加 queue，直接没有左右孩子可以添加入其中即可。
- 最终返回每一步我们 shift 出来的先进入队列的元素，也可以理解为每一步的根节点。
- TC: O(n) = n -> 需要遍历所以节点
- SC: O(n) = n -> 当作为平衡二叉树时，深度为 n/2 -> 即为 n

### 打印二叉树 2

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

例如:
给定二叉树: [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：
[
[3],
[9,20],
[15,7]
]

## solution:

- 在题 1 的基础上，输出结果要把相同的层数的子节点放在同一个数组中。还是 BFS 的思路，广度优先，运用到队列。
- 一点点改变，就是题一的时候，我们不在意层数，单纯的把子节点放到队尾即可。这题我们需要在定义 queue 的时候，添加一个变量就是层数。
- queue = [[root, 0]] -> 这样定义出来的 queue，都是带有了当前层数的信息。然后，我们在"递归"/"循环"的时候，我们可以做一个 level+1 的操作，
  便能轻易的得到下一层的信息了。然后我们把 root.val push 到结果数组的时候，就能指定那一层/那一个数组（二维数组中的数组）来接收结果。
- TC: O(n) = n
- SC: O(n) = n

### 从上到下打印二叉树 3

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

例如:
给定二叉树: [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

[
[3],
[20,9],
[15,7]
]

## solution 1:
- 原理BFS Queue与题2一致。按层输出。
- 对结果进行处理，偶数层不变，奇数层逆序。
- TC: O(n) = n
- SC: O(n) = n

## solution 2:
- 原理一致。在循环中进行处理。
- 奇数层，unshift头插入输出数组。
- 偶数层，push尾插入输出数组。
- TC/SC: O(n) = n