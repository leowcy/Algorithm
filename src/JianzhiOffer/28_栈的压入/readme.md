### 栈的压入 弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。

## solution 1: 找规律 递归

提供一个非辅助栈的写法。只需要一次遍历 popped 数组即可。
我们判断下一个 pop 出来的数字是否符合要求。要求如下：

首先求得下一个需要弹出的元素在原 pushed 栈中的 index。
index 需要满足如下条件 - 它可以比当前的数字在栈中的 index 大 或者 是原 pushed 栈中的前一个未被使用过的元素，并且下一个元素需要未被使用过。
取个例子: [1,2,3] [3,2,1] - 当前为 3,下一个数字为 2，我们去判断 2 是否满足要求。在原栈中，2 的 index 为 1,3 的 index 为 2。3 的上一个未被使用过的元素就是 2，所以满足要求，我们就去判断下一个元素 2。直到遍历了所有 pop 中的元素，返回 true。但凡有一个不满足，返回 false。
Time Complexity: O(n) = n -> 一次遍历 pooped 栈即可
Space Complexity: O(n) = n -> 有一个 map 来记录元素是否被访问过

## solution 2: 辅助栈

构建一个辅助栈，规律如下。遍历pushed数组，一直把当前元素push进去辅助栈中。在辅助栈中，我们每次循环都判断一个条件，就是当前push进去的元素，是否为popped数组的第一个元素，如果是，那么我们进行一个pop操作，把push进去的元素pop出来，同时把popped的index++。最终当遍历完pushed数组，我们判断辅助栈长度是否为空，因为如果为空，说明都能pop出来，序列满足条件。
TC：O(n) = n -> 每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。-> n
SC: O(n) = n -> 辅助栈 stack 最多同时存储 n 个元素。