### 顺时针打印矩阵
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

示例 2：
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

### 解题思路

这道题我的思路是寻找规律。我发现如下规律：
1. 优先向右移动
2. 如果右方超出二维数组或者值为null，向下移动。
3. 如果无法向右或者向下，向左移动。
4. 最低优先级就是向上移动，但是这里有一个trick，就是如果向上，就要一直向上直到无法移动，这样才能满足我们的顺时针扫描。

基于上述思路，我写出了如下的递归算法。参数可能有点多，但是方便阅读。upFlag用来判断是否一直向上移动。size用来判断是否已经搜索完成。

还有一行可能有些难理解是 - matrix[indexOfRow][indexOfColumn] = res.pop();
这里的原因是当我们向上移动的时候，我们已经存储了每一步的值，并且把遍历过的元素改成了null。但是举个例子：
```
1 2 3     null null null
4 5 6  -> null 5    null
7 8 9     null 8    null
```
当运行到这个情况的时候，4个位置被改成了null。但是我们想去遍历5，因为可以向右。所以这里我把4的值重新改回来，相当于把4看做初始的1的位置，同时把upFlag改成false表示在4的位置不再向上移动，因为我们已经探索过1的位置是null了。然后我们重新遍历4 -> 5 -> 8.

这里还有一点就是设置size和添加条件if (res.length < size) {} -> 因为我们终结递归的时候，如果不去对比res的length，那么我们会一直执行res.pop()的操作，无法结束。所以需要添加一个条件来阻止无限循环。

- Time Complexity: O(n) = m*n -> size of the 2d array
- Space Complexity: O(n) = 1 -> no extra space needed. The return res array doesn't count.

## solution 2:
- 先把size计算出来，然后for loop size直到填满。
- 定义四个方向，右-下-左-上。每次当触碰到边界或者遇到访问过的数组，顺时针转向。这里巧妙的是顺时针转向用的是 +1 然后对4取余，得出下一个方向的改变值。
- 边界条件定义好 - 溢出、index<0、碰到访问过的数组，都需要变相即可。
- TC： O(n) = m*n = size -> 遍历所有node。
- SC： O(n) = m*n -> 建立了一个这样的map来存储访问过的节点。