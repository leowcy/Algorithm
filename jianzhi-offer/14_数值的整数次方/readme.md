### 数值的整数次方

实现  pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

示例 1：
输入：x = 2.00000, n = 10
输出：1024.00000

示例 2：
输入：x = 2.10000, n = 3
输出：9.26100

示例 3：
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25

提示：
-100.0 < x < 100.0
-2^31 <= n <= 2^31-1
-10^4 <= x^n <= 10^4

## solution 1: Brute force

- Straight forward solution -> Calculate the product one by one -> Drawback: This solution will be timeout.
- Time Complexity: O(n) = n
- Space Complexity: O(n) = 1

## solution 2: Bit operations

- 这个方法借鉴评论区大神，很巧妙的位运算。我们在计算 n 的 m 次方的时候，可以把 m 化为一个二进制数。例如 3 的 5 次方为 3^(101)次方。
  然后进一步推论，101 -> 2^2 和 2^0 -> 因此分为了 3 的 4 次方+3 的 1 次方。
- 第二个巧妙地点在于我们用 & 位运算。 &运算规律是相当于乘法，只有两个均为 1，结果才为 1。因此我们用次方 m & 1 来进行计算次方
  的二进制数的末位。如果 m&1 为 1，则证明次方的二进制数末位为 1，因此我们需要把它结果累乘到 res 中。如果为 0，忽略。
- 第三点为每次循环，我们都把 m/2，在二进制中，整除 2 的操作可以理解为把末尾删去。（证明忽略）
- 根据上述规律，我们的算法思路如下：
  1. 初始化 res = 1
  2. 当 m（次方）不为 0，我们进行位运算，m&1。
  3. 若 m&1 的结果为 1，我们累乘进入 res。
  4. 每一次循环，我们都把 n = n^2，进行自乘。原因是从二进制的最低位往最高位移动的时候，我们的基底不是固定不变的。第一个二进制位为 n，第二个
     为 n^2，第三位为(n^2)^2 = n^4，以此类推。
  5. 每次循环结束需要对 m 次方进行整除 2 的操作，在二进制中会移除掉已经计算过的末尾。
  6. 当循环结束，根据正负，我们进行结果的输出。
- TC: O(n) = log2N -> 每次循环我们都进行整除 2 的处理，因为复杂度为 log2N。
- SC: O(n) = 1

## solution 3: 二分递归

- 这个二分递归就简单粗暴了。简单地说就是先判断次方的奇偶，如果为基数，则多乘一个 x 自身即可。然后无限递归下去。
- 关键点在于把次方 m 降为 0 或 1 的时候，把结果正确定义出来。
- TC: O(n) = log2N -> 因为也是整除 2 得递归
- SC: O(n) = 1
